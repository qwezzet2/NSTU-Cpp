#include <iostream>
#include <locale.h>
struct N_spk { // структура для эл нижнего списка 
    int znach_n;          // значения элемента низа
    N_spk* next_n;  // указатель на след эл низа
    N_spk(int v_spk) {
        znach_n = v_spk;    // значение эл нижнего уровня
        next_n = nullptr;   // указатель на след элемент низа (инициализация)
    }
};
struct V_spk {// структура для эл верхнего списка 
    int value;              // значения элемента верха
    N_spk* head_n; // указатель на голову низа
    V_spk* next_v;         // указатель на след эл верха
    V_spk(int val) {
        value = val;         // значение эл верхнего уровняя
        head_n = nullptr;    // указатель на след голову низа (инициализация)
        next_v = nullptr;    // указатель на след элемент верха (инициализация)
    }
};
V_spk* sozd_spk(int* wss, int N, int W) {// функция для создания списка
    V_spk* head_v = nullptr;   // указатель на голову верха
    V_spk* tek_v = nullptr; // указатель на текущий элемент списка верха
    for (int i = 0; i < N; ++i) {    // проход по всем элементам массива
        V_spk* new_v = new V_spk(wss[i]); // создание нового эл списка верха 
        new_v->next_v = nullptr; // след элемент в nullptr
        N_spk* head_n = nullptr; // указатель на голову списка низа
        N_spk* tek_n = nullptr; // указатель на текущий элемент списка низа
        for (int j = 0; j < N; ++j) { //проход по всем элементам массива для создания низа
            if (i != j && abs(wss[i] - wss[j]) <= W) { // проверяем чтобы текущий индекс не был равен индексу i и чтобы разница между значениями была не больше W
                N_spk* new_n = new N_spk(wss[j]); // создание нового элемента списка низа
                if (head_n == nullptr) { // Если пусто делаем новый элемент головой 
                    head_n = new_n;
                    tek_n = head_n;
                }
                else {
                    tek_n->next_n = new_n; // иначе добавляем в конец списка
                    tek_n = new_n;
                }
            }
        }
        new_v->head_n = head_n; // присоединяем список нижнего уровня к текущему элементу списка верхнего уровня
        if (head_v == nullptr) { //  текущий элемент списка верха к общему списку (добавляем постепенно)
            head_v = new_v;
            tek_v = head_v;
        }
        else {
            tek_v->next_v = new_v;
            tek_v = new_v;
        }
    }
    return head_v; // указатель на голову списка верха
}
void vvd(V_spk* head) { // Функция для вывода списка
    V_spk* tek_v = head; // указатель на текущий элемент списка верха
    int ind = 0; // индекс самого эл
    while (tek_v != nullptr) { // проход по всем элементам списка верха
        std::cout << "Индекс " << ind << " Значение " << tek_v->value << std::endl; // выводим индекс и значение 
        N_spk* soot = tek_v->head_n; // указатель на низ (элемент соотв)
        while (soot != nullptr) { // проход по всем элементам списка нижнего уровня текущего элемента списка верхнего уровня
            std::cout << "  Соответсвующие значения " << soot->znach_n << std::endl; // выводим значение текущего элемента списка нижнего уровня
            soot = soot->next_n; // переходим к следующему элементу списка низа
        }
        tek_v = tek_v->next_v; // переходим к следующему элементу списка верха
        ind++; // идем дальше
    }
    std::cout << " " << std::endl;
}
int main() {
    setlocale(LC_ALL, "Rus"); // русификатор
    const int N1 = 5; // размер массива
    int arr1[N1] = { 1, 3, 5, 7, 9 }; // массив чисел
    int W1 = 4; // параметр W
    V_spk* spk1 = sozd_spk(arr1, N1, W1); // создание списка
    vvd(spk1); // вывод списка
    const int N2 = 4; // размер массива
    int arr2[N2] = { 0, 5, 12, 18 }; // массив чисел
    int W2 = 10; // параметр W
    V_spk* spk2 = sozd_spk(arr2, N2, W2); // создание списка
    vvd(spk2); // вывод списка
    return 0;
}
